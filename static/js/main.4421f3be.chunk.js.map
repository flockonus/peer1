{"version":3,"sources":["../node_modules/peerjs/dist sync","p2p.ts","video.js","App.js","index.js"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","myStream","selfPeer","registryId","isInit","isConnRegistry","isRegistry","subscriptions","peers","window","myId","randId","Math","random","toString","substr","includes","location","hostname","localStorage","getItem","setItem","getMyId","emit","status","Object","freeze","forEach","cb","subscribeToRegistryOrBecomeIt","console","log","regTimeout","setTimeout","becomeRegistry","registryConn","connect","reliable","on","send","type","err","warn","data","clearTimeout","payload","ids","call","remoteStream","registry","Peer","info","conn","peer","initWebCam","a","navigator","mediaDevices","getUserMedia","audio","video","width","ideal","height","then","stream","catch","error","App","props","urlParams","URLSearchParams","search","state","selfStream","roomId","get","initCam","active","document","querySelector","volume","srcObject","onloadedmetadata","event","play","this","setState","initNetwork","bind","p2pState","push","answer","videos","key","videoEl","getElementById","className","renderPeerVideos","React","Component","ReactDOM","render"],"mappings":"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","file":"static/js/main.4421f3be.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 18;","import Peer from 'peerjs';\n\nlet registryId = 'peer1-registry-';\nconst registryConnTimeout = 5 * 1000;\nlet isInit = false;\nlet isConnRegistry = false;\nlet isRegistry = false;\n// can hold one subscription\nlet subscriptions: any = [];\nlet myStream: MediaStream;\n\ninterface P2PMessage {\n  type: string;\n  payload: any; // it's always an object but attributes vary by `type`\n}\n\n// keep a list of all messages ever sent\n// const messages = [];\n\n// ref to own instance connection\nlet selfPeer: Peer;\n\n// keeps a map of peers\nconst peers: { [key: string]: MediaStream } = {};\n(window as any)['_peers'] = peers;\n\nconst myId: string = getMyId();\n\nconsole.log('my id is', myId);\n\nexport function init(roomId: string, stream: MediaStream) {\n  myStream = stream;\n  if (isInit) {\n    console.warn('P2P is already init, ignoring');\n    return;\n  } else {\n    isInit = true;\n  }\n\n  registryId += roomId;\n  selfPeer = new Peer(myId);\n  (window as any)['_selfPeer'] = selfPeer;\n\n  selfPeer.on('error', err => {\n    console.warn('selfPeer error', err);\n  });\n\n  selfPeer.on('open', () => {\n    console.info('selfPeer open');\n    subscribeToRegistryOrBecomeIt();\n  });\n\n  selfPeer.on('call', (call) => {\n    // Answer the call with an A/V stream.\n    call.answer(myStream);\n    call.on('stream', (remoteStream) => {\n      peers[call.peer] = remoteStream;\n      emit();\n    });\n  })\n\n  selfPeer.on('connection', conn => {\n    console.log('selfPeer connection', conn.peer);\n    // so apparently we need to connect back in order to send messages!\n\n    // if (!(conn.peer in peers)) {\n    //   console.log('>instantiating reciprocal connection');\n    //   // NOT DATA ANYMORE peers[conn.peer] = selfPeer.connect(conn.peer, {reliable: true});\n    //   emit();\n    // }\n    \n    // conn.on('data', ({ type, payload }) => {\n    //   console.log(`MSG[${conn.peer}]:`, type, payload)\n    //   switch (type) {\n    //     case 'hi':\n    //       break;\n    //     default:\n    //       console.log('msg uknown', type, payload);\n    //       break;\n    //   }\n    // });\n    \n\n    conn.on('close', () => {\n      console.log('selfPeer connection close');\n      // not confident about the re-connect logic 🤔\n      delete peers[conn.peer];\n      emit();\n    })\n  });\n}\n\n// send a message to all connected peers\n// export function broadcastChat(msg: string) {\n//   for(const key in peers) {\n//     const conn = peers[key];\n//     if (key === registryId) continue;\n//     conn.send({type: 'chat', payload: {msg}})\n//     console.log('sent to', conn.peer);\n//   }\n// }\n// (window as any)._broadcastChat = broadcastChat;\n\n// \nexport function subscribe(cb: any) {\n  subscriptions.push(cb);\n}\n\n// send an update snapshot of public state\nfunction emit() {\n  const status = Object.freeze(getStatus());\n  subscriptions.forEach((cb:any) => cb(status));\n}\n\nexport function getStatus() {\n  return {\n    peers,\n    // Object.keys(peers).map(key => {\n    //   if (key === registryId) return null;\n    //   return peers[key]\n\n    // }).filter(x => x !== null),\n    isRegistry,\n    isConnRegistry,\n  }\n}\n\nfunction getMyId(): string {\n  const randId = 'peer1' + Math.random().toString(36).substr(2);\n  if (['localhost', '127.0.0.1'].includes(window.location.hostname)) {\n    // while in development makes ID non-sticky\n    return randId;\n  } else {\n    if (!localStorage.getItem('myid')) localStorage.setItem('myid', randId);\n    return localStorage.getItem('myid') as string;\n  }\n}\n\n// any new peer connecting gets a list of everyone who's online and tries to connect to them\n//   also keeps a connection to the registry for heartbeat purposes\nexport function subscribeToRegistryOrBecomeIt() {\n  console.log('connecting to registry..');\n\n  // will make an instance of registry if cant connect in Xms\n  const regTimeout = setTimeout(becomeRegistry, registryConnTimeout);\n\n  const registryConn = selfPeer.connect(registryId, { reliable: true });\n\n  registryConn.on('open', () => {\n    console.log('registryConn open');\n    registryConn.send({ type: 'register' });\n    isConnRegistry = true;\n    emit();\n  });\n\n  registryConn.on('error', (err) => {\n    console.warn('registryConn error', err);\n    isConnRegistry = false;\n    emit();\n  });\n\n  registryConn.on('close', () => {\n    console.warn('registryConn close');\n    // TODO become a registry?\n    isConnRegistry = false;\n    emit();\n  });\n\n  registryConn.on('data', (data: P2PMessage) => {\n    console.log('registry says:', data);\n    clearTimeout(regTimeout);\n    if (data.type === 'peerlist') {\n      const ids: string[] = data.payload.ids;\n      ids.forEach(id => {\n        // skip self\n        if (id === selfPeer.id) return;\n        console.log('calling...', id);\n        const call = selfPeer.call(id, myStream);\n        call.on('stream', (remoteStream) => {\n          peers[id] = remoteStream;\n          emit();\n        });\n        // peers[id] = call;\n\n        call.on('close', () => {\n          console.log('peer close', id);\n          delete peers[id];\n          emit();\n        })\n\n        call.on('open', () => {\n          // peers[id] = call;\n          // call.send({ type: 'hi', payload: {} });\n        });\n      });\n    }\n  });\n}\n\n// become the registry for the service\nexport function becomeRegistry() {\n  console.log('becomeRegistry !');\n  const peers: any = {};\n\n  const registry = new Peer(registryId);\n\n  registry.on('open', () => {\n    console.log('registry: open 🤖📝')\n    isRegistry = true;\n    emit();\n    subscribeToRegistryOrBecomeIt()\n  });\n\n  registry.on('error', err => {\n    console.info('registry: error', err);\n    // if (err.type === \"unavailable-id\") {\n    // something happened.. on localhost multiple tabs a race condition is usual\n    subscribeToRegistryOrBecomeIt();\n  });\n\n  registry.on('connection', conn => {\n    const id = conn.peer;\n    console.log('registry: connection', id);\n\n    conn.on('open', () => {\n      console.log('registry: conn open', id);\n      if (!(id in peers)) {\n        peers[id] = conn;\n        // tell it about everyone else\n        conn.send({\n          type: 'peerlist',\n          payload: { ids: Object.keys(peers) },\n        })\n      }\n    });\n\n    conn.on('error', (err) =>{\n      console.log('registry: conn error', id, err);\n      delete peers[id];\n    });\n\n    conn.on('close', () => {\n      console.log('registry: conn close', id);\n      delete peers[id];\n    });\n  })\n\n  registry.on('disconnected', () => {\n    console.log('registry: disconnected')\n  });\n}\n\n","export async function initWebCam() {\n  return navigator.mediaDevices.getUserMedia({\n    audio: true,\n    // facingMode: \"user\",\n    video: {\n      width: { ideal: 640 },\n      height: { ideal: 480 }\n    }\n  })\n  .then(function (stream) {\n    // console.log('got video stream', stream);\n    // nothing extra to do here\n    return stream;\n  })\n  .catch(function (err) {\n    /* handle the error */\n    console.error('Failed to get local stream', err);\n  });\n}","import React from 'react';\nimport './App.css';\nimport * as P2P from \"./p2p\";\nimport { initWebCam } from \"./video\";\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    const urlParams = new URLSearchParams(window.location.search);\n    this.state = {\n      selfStream: null,\n      roomId: urlParams.get('room') || 'default00000',\n      peers: {},\n    };\n    this.initCam();\n  }\n\n  async initCam() {\n    try {\n      const stream = await initWebCam();\n      if (!stream || !stream.active) {\n        throw new Error('missing stream');\n      }\n      var video = document.querySelector('.video-self');\n      video.volume = 0;\n      video.srcObject = stream;\n      video.onloadedmetadata = function(event) {\n        video.play();\n      };\n      this.setState(state => {\n        return { selfStream: stream }\n      },\n        () => setTimeout(this.initNetwork.bind(this), Math.random() * 1000)\n      );\n    } catch (err) {\n      // TODO make a fatal message here\n      console.error(err);\n    }\n  }\n\n  async initNetwork() {\n    P2P.subscribe((p2pState) => {\n      console.log('p2pState', p2pState);\n      this.setState({\n        peers: p2pState.peers,\n      });\n    });\n    await P2P.init(this.state.roomId, this.state.selfStream);\n  }\n\n  renderPeerVideos(peers) {\n    const videos = [];\n    for (const key in peers) {\n      const videoEl = <video key={`key-${key}`} id={key}></video>;\n      videos.push(videoEl);\n    }\n    return videos;\n  }\n\n  // after each render, try to link the video stream to the video element\n  componentDidUpdate() {\n    for (const key in this.state.peers) {\n      const videoEl = document.getElementById(key);\n      if (!videoEl.srcObject) {\n        videoEl.srcObject = this.state.peers[key];\n        videoEl.onloadedmetadata = function(event) {\n          videoEl.play();\n        };\n        videoEl.volume = 1;\n      }\n      console.log(videoEl);\n    }\n  }\n\n  render() {\n    \n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <div>HEADER</div>\n          <div>OHAYOOOOO</div>\n          <video className=\"video-self\">Acquiring stream</video>\n        </header>\n        <div className=\"stage\">\n          {this.renderPeerVideos(this.state.peers)}\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n// import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}